`timescale 1ns / 1ps
module Replicacao #(
    parameter LARGURA_ORIG = 160,
    parameter ALTURA_ORIG  = 120
)(
    input  wire       clk,
    input  wire       rst,
    input  wire       start,          // já vem como pulso de 1 ciclo
    input  wire [7:0] pixel_in,
    input  wire [1:0] zoom_select,   // 00=1x, 01=2x, 10=4x

    output reg  [18:0] ram_addr,
    output wire [14:0] rom_addr,
    output reg        wren,
    output reg  [7:0] pixel_out,
    output reg        done,
    output reg        led_test
);

	 reg [1:0] fator_zoom;
    // -----------------------------
    // FSM
    // -----------------------------
    localparam IDLE    = 2'b00;
    localparam PROCESS = 2'b01;
    localparam FINAL   = 2'b10;

    reg [1:0] estado, prox_estado;

    // -----------------------------
    // Contadores
    // -----------------------------
    reg [9:0] cont_x_orig, cont_y_orig;   // posição na ROM
    reg [9:0] block_x, block_y;           // posição dentro do bloco
    reg [7:0] pixel_hold;                 // armazena o pixel atual da ROM

    reg [2:0] block_size_reg;             // valor do zoom congelado

    // -----------------------------
    // Captura BLOCK_SIZE no start
    // -----------------------------
    always @(posedge clk or posedge rst) begin
        if (rst)
            block_size_reg <= 1;
        else if (start) begin
            case (zoom_select)
                2'b01: block_size_reg <= 2;
                2'b10: block_size_reg <= 4;
                default: block_size_reg <= 1;
            endcase
        end
    end

    // -----------------------------
    // Tamanho da saída
    // -----------------------------
    wire [9:0] LARGURA_SAIDA = LARGURA_ORIG * block_size_reg;
    wire [9:0] ALTURA_SAIDA  = ALTURA_ORIG  * block_size_reg;

    // -----------------------------
    // FSM Síncrona
    // -----------------------------
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            estado       <= IDLE;
            prox_estado  <= IDLE;
            cont_x_orig  <= 0;
            cont_y_orig  <= 0;
            block_x      <= 0;
            block_y      <= 0;
            ram_addr     <= 0;
            pixel_out    <= 0;
            pixel_hold   <= 0;
            wren         <= 0;
            done         <= 0;
            led_test     <= 0;
        end else begin
            estado <= prox_estado;

            case (estado)
                // ---------------- IDLE ----------------
                IDLE: begin
                    prox_estado <= IDLE;
                    if (start) begin
                        cont_x_orig <= 0;
                        cont_y_orig <= 0;
                        block_x     <= 0;
                        block_y     <= 0;
                        ram_addr    <= 0;
                        pixel_out   <= 0;
                        pixel_hold  <= pixel_in; // captura primeiro pixel
                        wren        <= 0;
                        done        <= 0;
                        prox_estado <= PROCESS;  // inicia o processamento
                    end
                end

                // ---------------- PROCESS ----------------
                PROCESS: begin
                    wren      <= 1'b1;
                    pixel_out <= pixel_hold;
                    prox_estado <= PROCESS;

                    ram_addr <= (cont_y_orig * block_size_reg + block_y) * LARGURA_SAIDA
                              + (cont_x_orig * block_size_reg + block_x);

                    if (block_x == block_size_reg-1 && block_y == block_size_reg-1) begin
                        block_x <= 0;
                        block_y <= 0;

                        if (cont_x_orig == LARGURA_ORIG-1) begin
                            cont_x_orig <= 0;
                            if (cont_y_orig == ALTURA_ORIG-1) begin
                                prox_estado <= FINAL;
                            end else begin
                                cont_y_orig <= cont_y_orig + 1;
                            end
                        end else begin
                            cont_x_orig <= cont_x_orig + 1;
                        end

                        pixel_hold <= pixel_in; // captura próximo pixel
                    end else begin
                        if (block_x < block_size_reg-1)
                            block_x <= block_x + 1;
                        else begin
                            block_x <= 0;
                            block_y <= block_y + 1;
                        end
                    end
                end

                // ---------------- FINAL ----------------
                FINAL: begin
                    done        <= 1'b1;
                    prox_estado <= IDLE;
                    led_test    <= ~led_test;
                end
            endcase
        end
    end

    // -----------------------------
    // Endereço ROM
    // -----------------------------
    assign rom_addr = cont_y_orig * LARGURA_ORIG + cont_x_orig;

endmodule
